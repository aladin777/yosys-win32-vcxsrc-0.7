cell_help["$not"] = "\n"
"    $not (A, Y)\n"
"\n"
"A bit-wise inverter. This corresponds to the Verilog unary prefix '~' operator.\n"
"\n";
cell_code["$not+"] = "module \\$not (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = ~$signed(A);\n"
"        end else begin:BLOCK2\n"
"            assign Y = ~A;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$pos"] = "\n"
"    $pos (A, Y)\n"
"\n"
"A buffer. This corresponds to the Verilog unary prefix '+' operator.\n"
"\n";
cell_code["$pos+"] = "module \\$pos (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$neg"] = "\n"
"    $neg (A, Y)\n"
"\n"
"An arithmetic inverter. This corresponds to the Verilog unary prefix '-' operator.\n"
"\n";
cell_code["$neg+"] = "module \\$neg (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = -$signed(A);\n"
"        end else begin:BLOCK2\n"
"            assign Y = -A;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$and"] = "\n"
"    $and (A, B, Y)\n"
"\n"
"A bit-wise AND. This corresponds to the Verilog '&' operator.\n"
"\n";
cell_code["$and+"] = "module \\$and (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) & $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A & B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$or"] = "\n"
"    $or (A, B, Y)\n"
"\n"
"A bit-wise OR. This corresponds to the Verilog '|' operator.\n"
"\n";
cell_code["$or+"] = "module \\$or (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) | $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A | B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$xor"] = "\n"
"    $xor (A, B, Y)\n"
"\n"
"A bit-wise XOR. This corresponds to the Verilog '^' operator.\n"
"\n";
cell_code["$xor+"] = "module \\$xor (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) ^ $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A ^ B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$xnor"] = "\n"
"    $xnor (A, B, Y)\n"
"\n"
"A bit-wise XNOR. This corresponds to the Verilog '~^' operator.\n"
"\n";
cell_code["$xnor+"] = "module \\$xnor (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) ~^ $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A ~^ B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$reduce_and"] = "\n"
"    $reduce_and (A, B, Y)\n"
"\n"
"An AND reduction. This corresponds to the Verilog unary prefix '&' operator.\n"
"\n";
cell_code["$reduce_and+"] = "module \\$reduce_and (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = &$signed(A);\n"
"        end else begin:BLOCK2\n"
"            assign Y = &A;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$reduce_or"] = "\n"
"    $reduce_or (A, B, Y)\n"
"\n"
"An OR reduction. This corresponds to the Verilog unary prefix '|' operator.\n"
"\n";
cell_code["$reduce_or+"] = "module \\$reduce_or (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = |$signed(A);\n"
"        end else begin:BLOCK2\n"
"            assign Y = |A;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$reduce_xor"] = "\n"
"    $reduce_xor (A, B, Y)\n"
"\n"
"A XOR reduction. This corresponds to the Verilog unary prefix '^' operator.\n"
"\n";
cell_code["$reduce_xor+"] = "module \\$reduce_xor (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = ^$signed(A);\n"
"        end else begin:BLOCK2\n"
"            assign Y = ^A;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$reduce_xnor"] = "\n"
"    $reduce_xnor (A, B, Y)\n"
"\n"
"A XNOR reduction. This corresponds to the Verilog unary prefix '~^' operator.\n"
"\n";
cell_code["$reduce_xnor+"] = "module \\$reduce_xnor (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = ~^$signed(A);\n"
"        end else begin:BLOCK2\n"
"            assign Y = ~^A;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$reduce_bool"] = "\n"
"    $reduce_bool (A, B, Y)\n"
"\n"
"An OR reduction. This cell type is used instead of $reduce_or when a signal is\n"
"implicitly converted to a boolean signal, e.g. for operands of '&&' and '||'.\n"
"\n";
cell_code["$reduce_bool+"] = "module \\$reduce_bool (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = !(!$signed(A));\n"
"        end else begin:BLOCK2\n"
"            assign Y = !(!A);\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$shl"] = "\n"
"    $shl (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$shl+"] = "module \\$shl (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) << B;\n"
"        end else begin:BLOCK2\n"
"            assign Y = A << B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$shr"] = "\n"
"    $shr (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$shr+"] = "module \\$shr (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) >> B;\n"
"        end else begin:BLOCK2\n"
"            assign Y = A >> B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$sshl"] = "\n"
"    $sshl (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$sshl+"] = "module \\$sshl (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) <<< B;\n"
"        end else begin:BLOCK2\n"
"            assign Y = A <<< B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$sshr"] = "\n"
"    $sshr (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$sshr+"] = "module \\$sshr (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) >>> B;\n"
"        end else begin:BLOCK2\n"
"            assign Y = A >>> B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$shift"] = "\n"
"    $shift (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$shift+"] = "module \\$shift (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(B) < 0 ? A << -B : A >> B;\n"
"        end else begin:BLOCK2\n"
"            assign Y = A >> B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$shiftx"] = "\n"
"    $shiftx (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$shiftx+"] = "module \\$shiftx (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (Y_WIDTH > 0)\n"
"            if (B_SIGNED) begin:BLOCK1\n"
"                assign Y = A[$signed(B) +: Y_WIDTH];\n"
"            end else begin:BLOCK2\n"
"                assign Y = A[B +: Y_WIDTH];\n"
"            end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$fa"] = "\n"
"    $fa (A, B, C, X, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$fa+"] = "module \\$fa (A, B, C, X, Y);\n"
"    \n"
"    parameter WIDTH = 1;\n"
"    \n"
"    input [WIDTH-1:0] A, B, C;\n"
"    output [WIDTH-1:0] X, Y;\n"
"    \n"
"    wire [WIDTH-1:0] t1, t2, t3;\n"
"    \n"
"    assign t1 = A ^ B, t2 = A & B, t3 = C & t1;\n"
"    assign Y = t1 ^ C, X = (t2 | t3) ^ (Y ^ Y);\n"
"    \n"
"endmodule\n";
cell_help["$lcu"] = "\n"
"    $lcu (P, G, CI, CO)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$lcu+"] = "module \\$lcu (P, G, CI, CO);\n"
"    \n"
"    parameter WIDTH = 1;\n"
"    \n"
"    input [WIDTH-1:0] P, G;\n"
"    input CI;\n"
"    \n"
"    output reg [WIDTH-1:0] CO;\n"
"    \n"
"    integer i;\n"
"    always @* begin\n"
"        CO = 'bx;\n"
"        if (^{P, G, CI} !== 1'bx) begin\n"
"            CO[0] = G[0] || (P[0] && CI);\n"
"            for (i = 1; i < WIDTH; i = i+1)\n"
"                CO[i] = G[i] || (P[i] && CO[i-1]);\n"
"        end\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$alu"] = "\n"
"    $alu (A, B, CI, BI, X, Y, CO)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$alu+"] = "module \\$alu (A, B, CI, BI, X, Y, CO);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 1;\n"
"    parameter B_WIDTH = 1;\n"
"    parameter Y_WIDTH = 1;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] X, Y;\n"
"    \n"
"    input CI, BI;\n"
"    output [Y_WIDTH-1:0] CO;\n"
"    \n"
"    wire [Y_WIDTH-1:0] AA, BB;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign AA = $signed(A), BB = BI ? ~$signed(B) : $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign AA = $unsigned(A), BB = BI ? ~$unsigned(B) : $unsigned(B);\n"
"        end\n"
"    endgenerate\n"
"    \n"
"    // this is 'x' if Y and CO should be all 'x', and '0' otherwise\n"
"    wire y_co_undef = ^{A, A, B, B, CI, CI, BI, BI};\n"
"    \n"
"    assign X = AA ^ BB;\n"
"    assign Y = (AA + BB + CI) ^ {Y_WIDTH{y_co_undef}};\n"
"    \n"
"    function get_carry;\n"
"        input a, b, c;\n"
"        get_carry = (a&b) | (a&c) | (b&c);\n"
"    endfunction\n"
"    \n"
"    genvar i;\n"
"    generate\n"
"        assign CO[0] = get_carry(AA[0], BB[0], CI) ^ y_co_undef;\n"
"        for (i = 1; i < Y_WIDTH; i = i+1) begin:BLOCK3\n"
"            assign CO[i] = get_carry(AA[i], BB[i], CO[i-1]) ^ y_co_undef;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$lt"] = "\n"
"    $lt (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$lt+"] = "module \\$lt (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) < $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A < B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$le"] = "\n"
"    $le (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$le+"] = "module \\$le (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) <= $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A <= B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$eq"] = "\n"
"    $eq (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$eq+"] = "module \\$eq (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) == $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A == B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$ne"] = "\n"
"    $ne (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$ne+"] = "module \\$ne (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) != $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A != B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$eqx"] = "\n"
"    $eqx (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$eqx+"] = "module \\$eqx (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) === $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A === B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$nex"] = "\n"
"    $nex (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$nex+"] = "module \\$nex (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) !== $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A !== B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$ge"] = "\n"
"    $ge (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$ge+"] = "module \\$ge (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) >= $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A >= B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$gt"] = "\n"
"    $gt (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$gt+"] = "module \\$gt (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) > $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A > B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$add"] = "\n"
"    $add (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$add+"] = "module \\$add (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) + $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A + B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$sub"] = "\n"
"    $sub (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$sub+"] = "module \\$sub (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) - $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A - B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$mul"] = "\n"
"    $mul (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$mul+"] = "module \\$mul (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) * $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A * B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$macc"] = "\n"
"    $macc (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$macc+"] = "module \\$macc (A, B, Y);\n"
"    \n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    parameter CONFIG = 4'b0000;\n"
"    parameter CONFIG_WIDTH = 4;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output reg [Y_WIDTH-1:0] Y;\n"
"    \n"
"    // Xilinx XSIM does not like $clog2() below..\n"
"    function integer my_clog2;\n"
"        input integer v;\n"
"        begin\n"
"            if (v > 0)\n"
"                v = v - 1;\n"
"            my_clog2 = 0;\n"
"            while (v) begin\n"
"                v = v >> 1;\n"
"                my_clog2 = my_clog2 + 1;\n"
"            end\n"
"        end\n"
"    endfunction\n"
"    \n"
"    localparam integer num_bits = CONFIG[3:0] > 0 ? CONFIG[3:0] : 1;\n"
"    localparam integer num_ports = (CONFIG_WIDTH-4) / (2 + 2*num_bits);\n"
"    localparam integer num_abits = my_clog2(A_WIDTH) > 0 ? my_clog2(A_WIDTH) : 1;\n"
"    \n"
"    function [2*num_ports*num_abits-1:0] get_port_offsets;\n"
"        input [CONFIG_WIDTH-1:0] cfg;\n"
"        integer i, cursor;\n"
"        begin\n"
"            cursor = 0;\n"
"            get_port_offsets = 0;\n"
"            for (i = 0; i < num_ports; i = i+1) begin\n"
"                get_port_offsets[(2*i + 0)*num_abits +: num_abits] = cursor;\n"
"                cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 +: num_bits];\n"
"                get_port_offsets[(2*i + 1)*num_abits +: num_abits] = cursor;\n"
"                cursor = cursor + cfg[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits];\n"
"            end\n"
"        end\n"
"    endfunction\n"
"    \n"
"    localparam [2*num_ports*num_abits-1:0] port_offsets = get_port_offsets(CONFIG);\n"
"    \n"
"    `define PORT_IS_SIGNED   (0 + CONFIG[4 + i*(2 + 2*num_bits)])\n"
"    `define PORT_DO_SUBTRACT (0 + CONFIG[4 + i*(2 + 2*num_bits) + 1])\n"
"    `define PORT_SIZE_A      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 +: num_bits])\n"
"    `define PORT_SIZE_B      (0 + CONFIG[4 + i*(2 + 2*num_bits) + 2 + num_bits +: num_bits])\n"
"    `define PORT_OFFSET_A    (0 + port_offsets[2*i*num_abits +: num_abits])\n"
"    `define PORT_OFFSET_B    (0 + port_offsets[2*i*num_abits + num_abits +: num_abits])\n"
"    \n"
"    integer i, j;\n"
"    reg [Y_WIDTH-1:0] tmp_a, tmp_b;\n"
"    \n"
"    always @* begin\n"
"        Y = 0;\n"
"        for (i = 0; i < num_ports; i = i+1)\n"
"        begin\n"
"            tmp_a = 0;\n"
"            tmp_b = 0;\n"
"    \n"
"            for (j = 0; j < `PORT_SIZE_A; j = j+1)\n"
"                tmp_a[j] = A[`PORT_OFFSET_A + j];\n"
"    \n"
"            if (`PORT_IS_SIGNED && `PORT_SIZE_A > 0)\n"
"                for (j = `PORT_SIZE_A; j < Y_WIDTH; j = j+1)\n"
"                    tmp_a[j] = tmp_a[`PORT_SIZE_A-1];\n"
"    \n"
"            for (j = 0; j < `PORT_SIZE_B; j = j+1)\n"
"                tmp_b[j] = A[`PORT_OFFSET_B + j];\n"
"    \n"
"            if (`PORT_IS_SIGNED && `PORT_SIZE_B > 0)\n"
"                for (j = `PORT_SIZE_B; j < Y_WIDTH; j = j+1)\n"
"                    tmp_b[j] = tmp_b[`PORT_SIZE_B-1];\n"
"    \n"
"            if (`PORT_SIZE_B > 0)\n"
"                tmp_a = tmp_a * tmp_b;\n"
"    \n"
"            if (`PORT_DO_SUBTRACT)\n"
"                Y = Y - tmp_a;\n"
"            else\n"
"                Y = Y + tmp_a;\n"
"        end\n"
"        for (i = 0; i < B_WIDTH; i = i+1) begin\n"
"            Y = Y + B[i];\n"
"        end\n"
"    end\n"
"    \n"
"    `undef PORT_IS_SIGNED\n"
"    `undef PORT_DO_SUBTRACT\n"
"    `undef PORT_SIZE_A\n"
"    `undef PORT_SIZE_B\n"
"    `undef PORT_OFFSET_A\n"
"    `undef PORT_OFFSET_B\n"
"    \n"
"endmodule\n";
cell_help["$div"] = "\n"
"    $div (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$div+"] = "module \\$div (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) / $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A / B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$mod"] = "\n"
"    $mod (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$mod+"] = "module \\$mod (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) % $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A % B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$pow"] = "\n"
"    $pow (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$pow+"] = "module \\$pow (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) ** $signed(B);\n"
"        end else if (A_SIGNED) begin:BLOCK2\n"
"            assign Y = $signed(A) ** B;\n"
"        end else if (B_SIGNED) begin:BLOCK3\n"
"            assign Y = A ** $signed(B);\n"
"        end else begin:BLOCK4\n"
"            assign Y = A ** B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$logic_not"] = "\n"
"    $logic_not (A, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$logic_not+"] = "module \\$logic_not (A, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED) begin:BLOCK1\n"
"            assign Y = !$signed(A);\n"
"        end else begin:BLOCK2\n"
"            assign Y = !A;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$logic_and"] = "\n"
"    $logic_and (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$logic_and+"] = "module \\$logic_and (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) && $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A && B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$logic_or"] = "\n"
"    $logic_or (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$logic_or+"] = "module \\$logic_or (A, B, Y);\n"
"    \n"
"    parameter A_SIGNED = 0;\n"
"    parameter B_SIGNED = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    generate\n"
"        if (A_SIGNED && B_SIGNED) begin:BLOCK1\n"
"            assign Y = $signed(A) || $signed(B);\n"
"        end else begin:BLOCK2\n"
"            assign Y = A || B;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$slice"] = "\n"
"    $slice (A, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$slice+"] = "module \\$slice (A, Y);\n"
"    \n"
"    parameter OFFSET = 0;\n"
"    parameter A_WIDTH = 0;\n"
"    parameter Y_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    output [Y_WIDTH-1:0] Y;\n"
"    \n"
"    assign Y = A >> OFFSET;\n"
"    \n"
"endmodule\n";
cell_help["$concat"] = "\n"
"    $concat (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$concat+"] = "module \\$concat (A, B, Y);\n"
"    \n"
"    parameter A_WIDTH = 0;\n"
"    parameter B_WIDTH = 0;\n"
"    \n"
"    input [A_WIDTH-1:0] A;\n"
"    input [B_WIDTH-1:0] B;\n"
"    output [A_WIDTH+B_WIDTH-1:0] Y;\n"
"    \n"
"    assign Y = {B, A};\n"
"    \n"
"endmodule\n";
cell_help["$mux"] = "\n"
"    $mux (A, B, S, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$mux+"] = "module \\$mux (A, B, S, Y);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    \n"
"    input [WIDTH-1:0] A, B;\n"
"    input S;\n"
"    output reg [WIDTH-1:0] Y;\n"
"    \n"
"    always @* begin\n"
"        if (S)\n"
"            Y = B;\n"
"        else\n"
"            Y = A;\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$pmux"] = "\n"
"    $pmux (A, B, S, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$pmux+"] = "module \\$pmux (A, B, S, Y);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter S_WIDTH = 0;\n"
"    \n"
"    input [WIDTH-1:0] A;\n"
"    input [WIDTH*S_WIDTH-1:0] B;\n"
"    input [S_WIDTH-1:0] S;\n"
"    output reg [WIDTH-1:0] Y;\n"
"    \n"
"    integer i;\n"
"    reg found_active_sel_bit;\n"
"    \n"
"    always @* begin\n"
"        Y = A;\n"
"        found_active_sel_bit = 0;\n"
"        for (i = 0; i < S_WIDTH; i = i+1)\n"
"            if (S[i]) begin\n"
"                Y = found_active_sel_bit ? 'bx : B >> (WIDTH*i);\n"
"                found_active_sel_bit = 1;\n"
"            end\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$lut"] = "\n"
"    $lut (A, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$lut+"] = "module \\$lut (A, Y);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter LUT = 0;\n"
"    \n"
"    input [WIDTH-1:0] A;\n"
"    output reg Y;\n"
"    \n"
"    wire lut0_out, lut1_out;\n"
"    \n"
"    generate\n"
"        if (WIDTH <= 1) begin:simple\n"
"            assign {lut1_out, lut0_out} = LUT;\n"
"        end else begin:complex\n"
"            \\$lut #( .WIDTH(WIDTH-1), .LUT(LUT                  ) ) lut0 ( .A(A[WIDTH-2:0]), .Y(lut0_out) );\n"
"            \\$lut #( .WIDTH(WIDTH-1), .LUT(LUT >> (2**(WIDTH-1))) ) lut1 ( .A(A[WIDTH-2:0]), .Y(lut1_out) );\n"
"        end\n"
"    \n"
"        if (WIDTH > 0) begin:lutlogic\n"
"            always @* begin\n"
"                casez ({A[WIDTH-1], lut0_out, lut1_out})\n"
"                    3'b?11: Y = 1'b1;\n"
"                    3'b?00: Y = 1'b0;\n"
"                    3'b0??: Y = lut0_out;\n"
"                    3'b1??: Y = lut1_out;\n"
"                    default: Y = 1'bx;\n"
"                endcase\n"
"            end\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$sop"] = "\n"
"    $sop (A, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$sop+"] = "module \\$sop (A, Y);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter DEPTH = 0;\n"
"    parameter TABLE = 0;\n"
"    \n"
"    input [WIDTH-1:0] A;\n"
"    output reg Y;\n"
"    \n"
"    integer i, j;\n"
"    reg match;\n"
"    \n"
"    always @* begin\n"
"        Y = 0;\n"
"        for (i = 0; i < DEPTH; i=i+1) begin\n"
"            match = 1;\n"
"            for (j = 0; j < WIDTH; j=j+1) begin\n"
"                if (TABLE[2*WIDTH*i + 2*j + 0] && A[j]) match = 0;\n"
"                if (TABLE[2*WIDTH*i + 2*j + 1] && !A[j]) match = 0;\n"
"            end\n"
"            if (match) Y = 1;\n"
"        end\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$tribuf"] = "\n"
"    $tribuf (A, EN, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$tribuf+"] = "module \\$tribuf (A, EN, Y);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    \n"
"    input [WIDTH-1:0] A;\n"
"    input EN;\n"
"    output [WIDTH-1:0] Y;\n"
"    \n"
"    assign Y = EN ? A : 'bz;\n"
"    \n"
"endmodule\n";
cell_help["$assert"] = "\n"
"    $assert (A, EN)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$assert+"] = "module \\$assert (A, EN);\n"
"    \n"
"    input A, EN;\n"
"    \n"
"    `ifndef SIMLIB_NOCHECKS\n"
"    always @* begin\n"
"        if (A !== 1'b1 && EN === 1'b1) begin\n"
"            $display(\"Assertion %m failed!\");\n"
"            $stop;\n"
"        end\n"
"    end\n"
"    `endif\n"
"    \n"
"endmodule\n";
cell_help["$assume"] = "\n"
"    $assume (A, EN)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$assume+"] = "module \\$assume (A, EN);\n"
"    \n"
"    input A, EN;\n"
"    \n"
"    `ifndef SIMLIB_NOCHECKS\n"
"    always @* begin\n"
"        if (A !== 1'b1 && EN === 1'b1) begin\n"
"            $display(\"Assumption %m failed!\");\n"
"            $stop;\n"
"        end\n"
"    end\n"
"    `endif\n"
"    \n"
"endmodule\n";
cell_help["$initstate"] = "\n"
"    $initstate (Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$initstate+"] = "module \\$initstate (Y);\n"
"    \n"
"    output reg Y = 1;\n"
"    reg [3:0] cnt = 1;\n"
"    reg trig = 0;\n"
"    \n"
"    initial trig <= 1;\n"
"    \n"
"    always @(cnt, trig) begin\n"
"        Y <= |cnt;\n"
"        cnt <= cnt + |cnt;\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$anyconst"] = "\n"
"    $anyconst (Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$anyconst+"] = "module \\$anyconst (Y);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    \n"
"    output [WIDTH-1:0] Y;\n"
"    \n"
"    assign Y = 'bx;\n"
"    \n"
"endmodule\n";
cell_help["$anyseq"] = "\n"
"    $anyseq (Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$anyseq+"] = "module \\$anyseq (Y);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    \n"
"    output [WIDTH-1:0] Y;\n"
"    \n"
"    assign Y = 'bx;\n"
"    \n"
"endmodule\n";
cell_help["$equiv"] = "\n"
"    $equiv (A, B, Y)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$equiv+"] = "module \\$equiv (A, B, Y);\n"
"    \n"
"    input A, B;\n"
"    output Y;\n"
"    \n"
"    assign Y = (A !== 1'bx && A !== B) ? 1'bx : A;\n"
"    \n"
"    `ifndef SIMLIB_NOCHECKS\n"
"    always @* begin\n"
"        if (A !== 1'bx && A !== B) begin\n"
"            $display(\"Equivalence failed!\");\n"
"            $stop;\n"
"        end\n"
"    end\n"
"    `endif\n"
"    \n"
"endmodule\n";
cell_help["$sr"] = "\n"
"    $sr (SET, CLR, Q)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$sr+"] = "module \\$sr (SET, CLR, Q);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter SET_POLARITY = 1'b1;\n"
"    parameter CLR_POLARITY = 1'b1;\n"
"    \n"
"    input [WIDTH-1:0] SET, CLR;\n"
"    output reg [WIDTH-1:0] Q;\n"
"    \n"
"    wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n"
"    wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n"
"    \n"
"    genvar i;\n"
"    generate\n"
"        for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n"
"            always @(posedge pos_set[i], posedge pos_clr[i])\n"
"                if (pos_clr[i])\n"
"                    Q[i] <= 0;\n"
"                else if (pos_set[i])\n"
"                    Q[i] <= 1;\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$ff"] = "\n"
"    $ff (D, Q)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$ff+"] = "module \\$ff (D, Q);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    \n"
"    input [WIDTH-1:0] D;\n"
"    output reg [WIDTH-1:0] Q;\n"
"    \n"
"    always @($global_clk) begin\n"
"        Q <= D;\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$dff"] = "\n"
"    $dff (CLK, D, Q)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$dff+"] = "module \\$dff (CLK, D, Q);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter CLK_POLARITY = 1'b1;\n"
"    \n"
"    input CLK;\n"
"    input [WIDTH-1:0] D;\n"
"    output reg [WIDTH-1:0] Q;\n"
"    wire pos_clk = CLK == CLK_POLARITY;\n"
"    \n"
"    always @(posedge pos_clk) begin\n"
"        Q <= D;\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$dffe"] = "\n"
"    $dffe (CLK, EN, D, Q)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$dffe+"] = "module \\$dffe (CLK, EN, D, Q);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter CLK_POLARITY = 1'b1;\n"
"    parameter EN_POLARITY = 1'b1;\n"
"    \n"
"    input CLK, EN;\n"
"    input [WIDTH-1:0] D;\n"
"    output reg [WIDTH-1:0] Q;\n"
"    wire pos_clk = CLK == CLK_POLARITY;\n"
"    \n"
"    always @(posedge pos_clk) begin\n"
"        if (EN == EN_POLARITY) Q <= D;\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$dffsr"] = "\n"
"    $dffsr (CLK, SET, CLR, D, Q)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$dffsr+"] = "module \\$dffsr (CLK, SET, CLR, D, Q);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter CLK_POLARITY = 1'b1;\n"
"    parameter SET_POLARITY = 1'b1;\n"
"    parameter CLR_POLARITY = 1'b1;\n"
"    \n"
"    input CLK;\n"
"    input [WIDTH-1:0] SET, CLR, D;\n"
"    output reg [WIDTH-1:0] Q;\n"
"    \n"
"    wire pos_clk = CLK == CLK_POLARITY;\n"
"    wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n"
"    wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n"
"    \n"
"    genvar i;\n"
"    generate\n"
"        for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n"
"            always @(posedge pos_set[i], posedge pos_clr[i], posedge pos_clk)\n"
"                if (pos_clr[i])\n"
"                    Q[i] <= 0;\n"
"                else if (pos_set[i])\n"
"                    Q[i] <= 1;\n"
"                else\n"
"                    Q[i] <= D[i];\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$adff"] = "\n"
"    $adff (CLK, ARST, D, Q)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$adff+"] = "module \\$adff (CLK, ARST, D, Q);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter CLK_POLARITY = 1'b1;\n"
"    parameter ARST_POLARITY = 1'b1;\n"
"    parameter ARST_VALUE = 0;\n"
"    \n"
"    input CLK, ARST;\n"
"    input [WIDTH-1:0] D;\n"
"    output reg [WIDTH-1:0] Q;\n"
"    wire pos_clk = CLK == CLK_POLARITY;\n"
"    wire pos_arst = ARST == ARST_POLARITY;\n"
"    \n"
"    always @(posedge pos_clk, posedge pos_arst) begin\n"
"        if (pos_arst)\n"
"            Q <= ARST_VALUE;\n"
"        else\n"
"            Q <= D;\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$dlatch"] = "\n"
"    $dlatch (EN, D, Q)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$dlatch+"] = "module \\$dlatch (EN, D, Q);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter EN_POLARITY = 1'b1;\n"
"    \n"
"    input EN;\n"
"    input [WIDTH-1:0] D;\n"
"    output reg [WIDTH-1:0] Q;\n"
"    \n"
"    always @* begin\n"
"        if (EN == EN_POLARITY)\n"
"            Q = D;\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$dlatchsr"] = "\n"
"    $dlatchsr (EN, SET, CLR, D, Q)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$dlatchsr+"] = "module \\$dlatchsr (EN, SET, CLR, D, Q);\n"
"    \n"
"    parameter WIDTH = 0;\n"
"    parameter EN_POLARITY = 1'b1;\n"
"    parameter SET_POLARITY = 1'b1;\n"
"    parameter CLR_POLARITY = 1'b1;\n"
"    \n"
"    input EN;\n"
"    input [WIDTH-1:0] SET, CLR, D;\n"
"    output reg [WIDTH-1:0] Q;\n"
"    \n"
"    wire pos_en = EN == EN_POLARITY;\n"
"    wire [WIDTH-1:0] pos_set = SET_POLARITY ? SET : ~SET;\n"
"    wire [WIDTH-1:0] pos_clr = CLR_POLARITY ? CLR : ~CLR;\n"
"    \n"
"    genvar i;\n"
"    generate\n"
"        for (i = 0; i < WIDTH; i = i+1) begin:bitslices\n"
"            always @*\n"
"                if (pos_clr[i])\n"
"                    Q[i] = 0;\n"
"                else if (pos_set[i])\n"
"                    Q[i] = 1;\n"
"                else if (pos_en)\n"
"                    Q[i] = D[i];\n"
"        end\n"
"    endgenerate\n"
"    \n"
"endmodule\n";
cell_help["$fsm"] = "\n"
"    $fsm (CLK, ARST, CTRL_IN, CTRL_OUT)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$fsm+"] = "module \\$fsm (CLK, ARST, CTRL_IN, CTRL_OUT);\n"
"    \n"
"    parameter NAME = \"\";\n"
"    \n"
"    parameter CLK_POLARITY = 1'b1;\n"
"    parameter ARST_POLARITY = 1'b1;\n"
"    \n"
"    parameter CTRL_IN_WIDTH = 1;\n"
"    parameter CTRL_OUT_WIDTH = 1;\n"
"    \n"
"    parameter STATE_BITS = 1;\n"
"    parameter STATE_NUM = 1;\n"
"    parameter STATE_NUM_LOG2 = 1;\n"
"    parameter STATE_RST = 0;\n"
"    parameter STATE_TABLE = 1'b0;\n"
"    \n"
"    parameter TRANS_NUM = 1;\n"
"    parameter TRANS_TABLE = 4'b0x0x;\n"
"    \n"
"    input CLK, ARST;\n"
"    input [CTRL_IN_WIDTH-1:0] CTRL_IN;\n"
"    output reg [CTRL_OUT_WIDTH-1:0] CTRL_OUT;\n"
"    \n"
"    wire pos_clk = CLK == CLK_POLARITY;\n"
"    wire pos_arst = ARST == ARST_POLARITY;\n"
"    \n"
"    reg [STATE_BITS-1:0] state;\n"
"    reg [STATE_BITS-1:0] state_tmp;\n"
"    reg [STATE_BITS-1:0] next_state;\n"
"    \n"
"    reg [STATE_BITS-1:0] tr_state_in;\n"
"    reg [STATE_BITS-1:0] tr_state_out;\n"
"    reg [CTRL_IN_WIDTH-1:0] tr_ctrl_in;\n"
"    reg [CTRL_OUT_WIDTH-1:0] tr_ctrl_out;\n"
"    \n"
"    integer i;\n"
"    \n"
"    task tr_fetch;\n"
"        input [31:0] tr_num;\n"
"        reg [31:0] tr_pos;\n"
"        reg [STATE_NUM_LOG2-1:0] state_num;\n"
"        begin\n"
"            tr_pos = (2*STATE_NUM_LOG2+CTRL_IN_WIDTH+CTRL_OUT_WIDTH)*tr_num;\n"
"            tr_ctrl_out = TRANS_TABLE >> tr_pos;\n"
"            tr_pos = tr_pos + CTRL_OUT_WIDTH;\n"
"            state_num = TRANS_TABLE >> tr_pos;\n"
"            tr_state_out = STATE_TABLE >> (STATE_BITS*state_num);\n"
"            tr_pos = tr_pos + STATE_NUM_LOG2;\n"
"            tr_ctrl_in = TRANS_TABLE >> tr_pos;\n"
"            tr_pos = tr_pos + CTRL_IN_WIDTH;\n"
"            state_num = TRANS_TABLE >> tr_pos;\n"
"            tr_state_in = STATE_TABLE >> (STATE_BITS*state_num);\n"
"            tr_pos = tr_pos + STATE_NUM_LOG2;\n"
"        end\n"
"    endtask\n"
"    \n"
"    always @(posedge pos_clk, posedge pos_arst) begin\n"
"        if (pos_arst) begin\n"
"            state_tmp = STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];\n"
"            for (i = 0; i < STATE_BITS; i = i+1)\n"
"                if (state_tmp[i] === 1'bz)\n"
"                    state_tmp[i] = 0;\n"
"            state <= state_tmp;\n"
"        end else begin\n"
"            state_tmp = next_state;\n"
"            for (i = 0; i < STATE_BITS; i = i+1)\n"
"                if (state_tmp[i] === 1'bz)\n"
"                    state_tmp[i] = 0;\n"
"            state <= state_tmp;\n"
"        end\n"
"    end\n"
"    \n"
"    always @(state, CTRL_IN) begin\n"
"        next_state <= STATE_TABLE[STATE_BITS*(STATE_RST+1)-1:STATE_BITS*STATE_RST];\n"
"        CTRL_OUT <= 'bx;\n"
"        // $display(\"---\");\n"
"        // $display(\"Q: %b %b\", state, CTRL_IN);\n"
"        for (i = 0; i < TRANS_NUM; i = i+1) begin\n"
"            tr_fetch(i);\n"
"            // $display(\"T: %b %b -> %b %b [%d]\", tr_state_in, tr_ctrl_in, tr_state_out, tr_ctrl_out, i);\n"
"            casez ({state, CTRL_IN})\n"
"                {tr_state_in, tr_ctrl_in}: begin\n"
"                    // $display(\"-> %b %b <-   MATCH\", state, CTRL_IN);\n"
"                    {next_state, CTRL_OUT} <= {tr_state_out, tr_ctrl_out};\n"
"                end\n"
"            endcase\n"
"        end\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$memrd"] = "\n"
"    $memrd (CLK, EN, ADDR, DATA)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$memrd+"] = "module \\$memrd (CLK, EN, ADDR, DATA);\n"
"    \n"
"    parameter MEMID = \"\";\n"
"    parameter ABITS = 8;\n"
"    parameter WIDTH = 8;\n"
"    \n"
"    parameter CLK_ENABLE = 0;\n"
"    parameter CLK_POLARITY = 0;\n"
"    parameter TRANSPARENT = 0;\n"
"    \n"
"    input CLK, EN;\n"
"    input [ABITS-1:0] ADDR;\n"
"    output [WIDTH-1:0] DATA;\n"
"    \n"
"    initial begin\n"
"        if (MEMID != \"\") begin\n"
"            $display(\"ERROR: Found non-simulatable instance of $memrd!\");\n"
"            $finish;\n"
"        end\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$memwr"] = "\n"
"    $memwr (CLK, EN, ADDR, DATA)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$memwr+"] = "module \\$memwr (CLK, EN, ADDR, DATA);\n"
"    \n"
"    parameter MEMID = \"\";\n"
"    parameter ABITS = 8;\n"
"    parameter WIDTH = 8;\n"
"    \n"
"    parameter CLK_ENABLE = 0;\n"
"    parameter CLK_POLARITY = 0;\n"
"    parameter PRIORITY = 0;\n"
"    \n"
"    input CLK;\n"
"    input [WIDTH-1:0] EN;\n"
"    input [ABITS-1:0] ADDR;\n"
"    input [WIDTH-1:0] DATA;\n"
"    \n"
"    initial begin\n"
"        if (MEMID != \"\") begin\n"
"            $display(\"ERROR: Found non-simulatable instance of $memwr!\");\n"
"            $finish;\n"
"        end\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$meminit"] = "\n"
"    $meminit (ADDR, DATA)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$meminit+"] = "module \\$meminit (ADDR, DATA);\n"
"    \n"
"    parameter MEMID = \"\";\n"
"    parameter ABITS = 8;\n"
"    parameter WIDTH = 8;\n"
"    parameter WORDS = 1;\n"
"    \n"
"    parameter PRIORITY = 0;\n"
"    \n"
"    input [ABITS-1:0] ADDR;\n"
"    input [WORDS*WIDTH-1:0] DATA;\n"
"    \n"
"    initial begin\n"
"        if (MEMID != \"\") begin\n"
"            $display(\"ERROR: Found non-simulatable instance of $meminit!\");\n"
"            $finish;\n"
"        end\n"
"    end\n"
"    \n"
"endmodule\n";
cell_help["$mem"] = "\n"
"    $mem (RD_CLK, RD_EN, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA)\n"
"\n"
"No help message for this cell type found.\n"
"\n";
cell_code["$mem+"] = "module \\$mem (RD_CLK, RD_EN, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA);\n"
"    \n"
"    parameter MEMID = \"\";\n"
"    parameter signed SIZE = 4;\n"
"    parameter signed OFFSET = 0;\n"
"    parameter signed ABITS = 2;\n"
"    parameter signed WIDTH = 8;\n"
"    parameter signed INIT = 1'bx;\n"
"    \n"
"    parameter signed RD_PORTS = 1;\n"
"    parameter RD_CLK_ENABLE = 1'b1;\n"
"    parameter RD_CLK_POLARITY = 1'b1;\n"
"    parameter RD_TRANSPARENT = 1'b1;\n"
"    \n"
"    parameter signed WR_PORTS = 1;\n"
"    parameter WR_CLK_ENABLE = 1'b1;\n"
"    parameter WR_CLK_POLARITY = 1'b1;\n"
"    \n"
"    input [RD_PORTS-1:0] RD_CLK;\n"
"    input [RD_PORTS-1:0] RD_EN;\n"
"    input [RD_PORTS*ABITS-1:0] RD_ADDR;\n"
"    output reg [RD_PORTS*WIDTH-1:0] RD_DATA;\n"
"    \n"
"    input [WR_PORTS-1:0] WR_CLK;\n"
"    input [WR_PORTS*WIDTH-1:0] WR_EN;\n"
"    input [WR_PORTS*ABITS-1:0] WR_ADDR;\n"
"    input [WR_PORTS*WIDTH-1:0] WR_DATA;\n"
"    \n"
"    reg [WIDTH-1:0] memory [SIZE-1:0];\n"
"    \n"
"    integer i, j;\n"
"    reg [WR_PORTS-1:0] LAST_WR_CLK;\n"
"    reg [RD_PORTS-1:0] LAST_RD_CLK;\n"
"    \n"
"    function port_active;\n"
"        input clk_enable;\n"
"        input clk_polarity;\n"
"        input last_clk;\n"
"        input this_clk;\n"
"        begin\n"
"            casez ({clk_enable, clk_polarity, last_clk, this_clk})\n"
"                4'b0???: port_active = 1;\n"
"                4'b1101: port_active = 1;\n"
"                4'b1010: port_active = 1;\n"
"                default: port_active = 0;\n"
"            endcase\n"
"        end\n"
"    endfunction\n"
"    \n"
"    initial begin\n"
"        for (i = 0; i < SIZE; i = i+1)\n"
"            memory[i] = INIT >>> (i*WIDTH);\n"
"    end\n"
"    \n"
"    always @(RD_CLK, RD_ADDR, RD_DATA, WR_CLK, WR_EN, WR_ADDR, WR_DATA) begin\n"
"    `ifdef SIMLIB_MEMDELAY\n"
"        #`SIMLIB_MEMDELAY;\n"
"    `endif\n"
"        for (i = 0; i < RD_PORTS; i = i+1) begin\n"
"            if (!RD_TRANSPARENT[i] && RD_CLK_ENABLE[i] && RD_EN[i] && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\n"
"                // $display(\"Read from %s: addr=%b data=%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n"
"                RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n"
"            end\n"
"        end\n"
"    \n"
"        for (i = 0; i < WR_PORTS; i = i+1) begin\n"
"            if (port_active(WR_CLK_ENABLE[i], WR_CLK_POLARITY[i], LAST_WR_CLK[i], WR_CLK[i]))\n"
"                for (j = 0; j < WIDTH; j = j+1)\n"
"                    if (WR_EN[i*WIDTH+j]) begin\n"
"                        // $display(\"Write to %s: addr=%b data=%b\", MEMID, WR_ADDR[i*ABITS +: ABITS], WR_DATA[i*WIDTH+j]);\n"
"                        memory[WR_ADDR[i*ABITS +: ABITS] - OFFSET][j] = WR_DATA[i*WIDTH+j];\n"
"                    end\n"
"        end\n"
"    \n"
"        for (i = 0; i < RD_PORTS; i = i+1) begin\n"
"            if ((RD_TRANSPARENT[i] || !RD_CLK_ENABLE[i]) && port_active(RD_CLK_ENABLE[i], RD_CLK_POLARITY[i], LAST_RD_CLK[i], RD_CLK[i])) begin\n"
"                // $display(\"Transparent read from %s: addr=%b data=%b\", MEMID, RD_ADDR[i*ABITS +: ABITS],  memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET]);\n"
"                RD_DATA[i*WIDTH +: WIDTH] <= memory[RD_ADDR[i*ABITS +: ABITS] - OFFSET];\n"
"            end\n"
"        end\n"
"    \n"
"        LAST_RD_CLK <= RD_CLK;\n"
"        LAST_WR_CLK <= WR_CLK;\n"
"    end\n"
"    \n"
"endmodule\n";
